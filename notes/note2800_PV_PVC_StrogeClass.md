#PV 描述的，是持久化存储数据卷

这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。

通常情况下，PV 对象是由运维人员事先创建在 Kubernetes 集群里待用的。

# PVC 描述的，则是 Pod 所希望使用的持久化存储的属性
PVC 对象通常由开发人员创建


而用户创建的 PVC 要真正被容器使用起来，就必须先和某个符合条件的 PV 进行绑定。这里要检查的条件，包括两部分：

第一个条件，当然是 PV 和 PVC 的 spec 字段。比如，PV 的存储（storage）大小，就必须满足 PVC 的要求。  
而第二个条件，则是 PV 和 PVC 的 storageClassName 字段必须一样


# 这个 PV 对象，又是如何变成容器里的一个持久化存储的呢？
所谓容器的 Volume，其实就是将一个宿主机上的目录，跟一个容器里的目录绑定挂载在了一起。

而所谓的“持久化 Volume”，指的就是这个宿主机上的目录，具备“持久性”。

大多数情况下，持久化 Volume 的实现，往往依赖于一个远程存储服务，比如：远程文件存储（比如，NFS、GlusterFS）、远程块存储（比如，公有云提供的远程磁盘）等等。

而 Kubernetes 需要做的工作，就是使用这些存储服务，来为容器准备一个持久化的宿主机目录，以供将来进行绑定挂载时使用。而所谓“持久化”，指的是容器在这个目录里写入的文件，都会保存在远程存储中，从而使得这个目录具备了“持久性”。


# 持久化两阶段处理

这个准备“持久化”宿主机目录的过程，我们可以形象地称为“两阶段处理”。


为虚拟机挂载远程磁盘的操作，对应的正是“两阶段处理”的第一阶段。在 Kubernetes 中，我们把这个阶段称为 Attach。

将磁盘设备格式化并挂载到 Volume 宿主机目录的操作，对应的正是“两阶段处理”的第二个阶段，我们一般称为：Mount。

# Kubernetes 又是如何定义和区分这两个阶段的呢？

对于“第一阶段”（Attach），Kubernetes 提供的可用参数是 nodeName，即宿主机的名字。  
而对于“第二阶段”（Mount），Kubernetes 提供的可用参数是 dir，即 Volume 的宿主机目录。  

关于 PV 的“两阶段处理”流程，是靠独立于 kubelet 主控制循环（Kubelet Sync Loop）之外的两个控制循环来实现的。

kubelet 的一个主要设计原则，就是它的主控制循环绝对不可以被 block。

# StorageClass
 StorageClass 对象的作用，其实就是创建 PV 的模板。

 具体地说，StorageClass 对象会定义如下两个部分内容：

第一，PV 的属性。比如，存储类型、Volume 的大小等等。  
第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。


Kubernetes 只会将 StorageClass 相同的 PVC 和 PV 绑定起来。  
StorageClass 并不是专门为了 Dynamic Provisioning 而设计的。

# 总结

PVC 描述的，是 Pod 想要使用的持久化存储的属性，比如存储的大小、读写权限等。

PV 描述的，则是一个具体的 Volume 的属性，比如 Volume 的类型、挂载目录、远程存储服务器地址等。

而 StorageClass 的作用，则是充当 PV 的模板。并且，只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。

需要注意的是，这套容器持久化存储体系，完全是 Kubernetes 项目自己负责管理的，并不依赖于 docker volume 命令和 Docker 的存储插件。当然，这套体系本身就比 docker volume 命令的诞生时间还要早得多。

